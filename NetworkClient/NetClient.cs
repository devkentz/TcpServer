using System;
using System.Buffers;
using System.Collections.Concurrent;
using System.Threading;
using System.Threading.Tasks;
using Google.Protobuf;
using Microsoft.Extensions.Logging;
using NetCoreServer;
using Network.Server.Common.Memory;
using Network.Server.Common.Packets;
using NetworkClient.Config;
using NetworkClient.Network;
using NetworkServer.ProtoGenerator;

namespace NetworkClient
{
    public enum ClientState
    {
        Disconnected,
        Connected,
    }

    public class BaseController
    {
        
    }

    public class NetClient : TcpClient
    {
        private readonly ILogger _logger;
        private readonly ProtoPacketParser _packetParser;
        private readonly ArrayPoolBufferWriter _receiveBuffer = new();
        private readonly ConcurrentQueue<(byte[] buffer, int length)> _sendQueue = new();
        private readonly ConcurrentQueue<NetworkPacket> _recvList = new();

        private readonly MessageHandler _handler;
        
        private TaskCompletionSource<bool>? _taskOnConnector;
        private TaskCompletionSource<IMessage>? _requestTcs = null;

        private readonly int _timeoutMs = 15000;
        private ushort _msgSeq = 0;

        public ClientState State => IsConnected ? ClientState.Connected : ClientState.Disconnected;

        public ConnectorConfig ConnectorConfig { get; private set; } = new();
        public Action<bool>? OnConnect;
        public Action? OnDisconnect;

        private long Sid => Socket.Handle.ToInt64();

        public NetClient(string address, int port, ILogger logger, MessageHandler handler)
            : base(address, port)
        {
            _logger = logger;
            _packetParser = new ProtoPacketParser();

            OptionNoDelay = true;
            OptionKeepAlive = true;
            OptionSendBufferSize = 1024 * 64;
            OptionReceiveBufferSize = 1024 * 256;

            _handler = handler;
        }

        public async Task<bool> ConnectAsync(CancellationToken cancellationToken = default, int timeoutMs = 15_000)
        {
            _taskOnConnector = new TaskCompletionSource<bool>(TaskCreationOptions.RunContinuationsAsynchronously);

            using var timeoutCts = new CancellationTokenSource(timeoutMs);

            try
            {
                using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token);

                Connect();

                return await _taskOnConnector.Task
                    .WaitAsync(linkedCts.Token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException) when (timeoutCts.IsCancellationRequested)
            {
                _logger.LogWarning("Connection timed out after {Timeout}ms", timeoutMs);
                throw new TimeoutException($"Connection timed out after {timeoutMs}ms");
            }
            catch (OperationCanceledException)
            {
                _logger.LogWarning("Connection cancelled by user");
                throw;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Connection failed");
                throw;
            }
        }

        public void DisconnectClient()
        {
            base.Disconnect();
        }

        public void Send(IMessage packet)
        {
            if (!IsConnected)
            {
                return;
            }

            var msgId = AutoGeneratedParsers.GetIdByInstance(packet);
            if (msgId == -1)
            {
                _logger.LogError("Unknown message type: {MessageType}", packet.GetType().Name);
                return;
            }

            EnqueueSend(new Header(msgId: msgId, msgSeq: _msgSeq), packet);
        }

        public async Task<TResponse> RequestAsync<TResponse>(IMessage request, CancellationToken cancellationToken = default)
            where TResponse : IMessage
        {
            if (!IsConnected)
                throw new NetClientException((ushort) InternalErrorCode.Disconnected, request);

            var msgId = AutoGeneratedParsers.GetIdByInstance(request);
            if (msgId == -1)
            {
                _logger.LogError("Unknown message type: {MessageType}", request.GetType().Name);
                throw new NetClientException((ushort) InternalErrorCode.InvalidMessage, request);
            }

            _requestTcs = new TaskCompletionSource<IMessage>(
                TaskCreationOptions.RunContinuationsAsynchronously);

            using var timeoutCts = new CancellationTokenSource(_timeoutMs);

            try
            {
                using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
                    cancellationToken, timeoutCts.Token);

                EnqueueSend(new Header(msgId: msgId, msgSeq: _msgSeq), request);

                return (TResponse) await _requestTcs.Task
                    .WaitAsync(linkedCts.Token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException) when (timeoutCts.IsCancellationRequested)
            {
                throw new TimeoutException($"Request timed out after {_timeoutMs}ms");
            }
        }

        private void SendQueueUpdate()
        {
            while (_sendQueue.TryDequeue(out var packet))
            {
                base.Send(packet.buffer, 0, packet.length);
                ArrayPool<byte>.Shared.Return(packet.buffer, true);
            }
        }

        public void Update()
        {
            if (State == ClientState.Disconnected)
                return;

            SendQueueUpdate();
            ProcessPacket();
        }

        private void ProcessPacket()
        {
            while (_recvList.TryDequeue(out var packet))
            {
                _handler.Handling(packet);
            }
        }

        private void EnqueueSend(Header header, IMessage message)
        {
            var size = (header, message).CalcSize();
            var buffer = ArrayPool<byte>.Shared.Rent(size);

            (header, message).WriteToSpan(buffer);
            _sendQueue.Enqueue((buffer, size));
        }

        protected override void OnConnected()
        {
            _logger.LogInformation("client connected - [sid:{Sid}]", Sid);

            _taskOnConnector?.SetResult(true);
            _taskOnConnector = null;
            OnConnect?.Invoke(true);
        }

        protected override void OnDisconnected()
        {
            _logger.LogInformation("TCP client disconnected - [sid:{Sid}]", Sid);
            _taskOnConnector = null;
        }

        protected override void OnReceived(byte[] buffer, long offset, long size)
        {
            try
            {
                _receiveBuffer.Write(buffer.AsSpan((int) offset, (int) size));
                var packets = _packetParser.Parse(_receiveBuffer);
                if (packets.Count == 0)
                    return;

                foreach (var packet in packets)
                {
                    if (_requestTcs != null && packet.Header.MsgSeq == _msgSeq + 1)
                    {
                        _msgSeq = packet.Header.MsgSeq;
                        _requestTcs?.SetResult(packet.Message);
                        continue;
                    }

                    _recvList.Enqueue(packet);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "OnReceived Exception");
                Disconnect();
            }
        }

        public new void Dispose()
        {
            base.Dispose();
            _receiveBuffer.Dispose();

            _requestTcs?.SetCanceled();
            _requestTcs = null;
        }
    }
}