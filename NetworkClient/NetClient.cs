using System;
using System.Buffers;
using System.Collections.Concurrent;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using Google.Protobuf;
using Microsoft.Extensions.Logging;
using Network.Server.Common.Memory;
using Network.Server.Common.Packets;
using NetworkClient.Config;
using NetworkClient.Network;
using NetworkServer.ProtoGenerator;
using TcpClient = NetCoreServer.TcpClient;

namespace NetworkClient
{
    public enum ClientState
    {
        Disconnected,
        Connected,
    }

    public class NetClient : TcpClient
    {
        private readonly ILogger _logger;
        private readonly ProtoPacketParser _packetParser;
        private readonly RpcRequestManager _rpcManager;
        private readonly NetClientConfig _config;
        private readonly ArrayPoolBufferWriter _receiveBuffer = new();
        private readonly ConcurrentQueue<NetworkPacket> _recvList = [];

        private readonly MessageHandler _handler;
        private TaskCompletionSource<bool>? _connectTcs;

        public ClientState State => IsConnected ? ClientState.Connected : ClientState.Disconnected;

        public Action<bool>? OnConnect;
        public Action? OnDisconnect;

        private long Sid => Socket.Handle.ToInt64();

        /// <summary>
        /// NetClient 생성자 (기본 설정 사용)
        /// </summary>
        public NetClient(string address, int port, ILogger logger, MessageHandler handler)
            : this(address, port, logger, handler, new SequentialRequestIdGenerator(), null)
        {
        }

        /// <summary>
        /// NetClient 생성자 (의존성 주입)
        /// </summary>
        public NetClient(
            string address,
            int port,
            ILogger logger,
            MessageHandler handler,
            IRequestIdGenerator? requestIdGenerator = null,
            NetClientConfig? config = null)
            : base(address, port)
        {
            _logger = logger;
            _handler = handler;
            _config = config ?? new NetClientConfig();

            _packetParser = new ProtoPacketParser();
            _rpcManager = new RpcRequestManager(
                requestIdGenerator ?? new SequentialRequestIdGenerator(),
                _config.RequestTimeout
            );

            OptionNoDelay = _config.NoDelay;
            OptionKeepAlive = _config.KeepAlive;
        }

        public async Task<bool> ConnectAsync(CancellationToken cancellationToken = default)
        {
            return await ConnectAsync(cancellationToken, (int)_config.ConnectTimeout.TotalMilliseconds);
        }

        public async Task<bool> ConnectAsync(CancellationToken cancellationToken = default, int timeoutMs = 15_000)
        {
            _connectTcs = new TaskCompletionSource<bool>(TaskCreationOptions.RunContinuationsAsynchronously);

            using var timeoutCts = new CancellationTokenSource(timeoutMs);

            try
            {
                using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token);

                base.ConnectAsync();

                return await _connectTcs.Task
                    .WaitAsync(linkedCts.Token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException) when (timeoutCts.IsCancellationRequested)
            {
                _logger.LogWarning("Connection timed out after {Timeout}ms", timeoutMs);
                throw new TimeoutException($"Connection timed out after {timeoutMs}ms");
            }
            catch (OperationCanceledException)
            {
                _logger.LogWarning("Connection cancelled by user");
                throw;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Connection failed");
                throw;
            }
            finally
            {
                _connectTcs = null;
            }
        }

        public void DisconnectClient()
        {
            base.Disconnect();
        }

        public void Send(IMessage packet)
        {
            if (!IsConnected)
            {
                _logger.LogWarning("Cannot send message - client is disconnected");
                return;
            }

            var msgId = AutoGeneratedParsers.GetIdByInstance(packet);
            if (msgId == -1)
            {
                _logger.LogError("Unknown message type: {MessageType}", packet.GetType().Name);
                return;
            }

            try
            {
                EnqueueSend(new Header(msgId: msgId, msgSeq: 0, requestId: 0), packet);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to send message - connection may be lost");
            }
        }

        public async Task<TResponse> RequestAsync<TResponse>(IMessage request, CancellationToken cancellationToken = default)
            where TResponse : IMessage
        {
            return (TResponse)await RequestAsync(request, cancellationToken);
        }

        public async Task<IMessage> RequestAsync(IMessage request, CancellationToken cancellationToken = default)
        {
            if (!IsConnected)
            {
                throw new NetClientException(
                    (ushort)InternalErrorCode.Disconnected,
                    "Cannot send request - client is disconnected",
                    request
                );
            }

            var msgId = AutoGeneratedParsers.GetIdByInstance(request);
            if (msgId == -1)
            {
                _logger.LogError("Unknown message type: {MessageType}", request.GetType().Name);
                throw new NetClientException(
                    (ushort)InternalErrorCode.InvalidMessage,
                    $"Unknown message type: {request.GetType().Name}",
                    request
                );
            }

            try
            {
                return await _rpcManager.SendRequestAsync(
                    requestId => EnqueueSend(new Header(msgId: msgId, msgSeq: 0, requestId: requestId), request),
                    cancellationToken
                );
            }
            catch (TimeoutException ex)
            {
                _logger.LogWarning(
                    "Request timed out - MsgId: {MsgId}, Type: {MessageType}",
                    msgId,
                    request.GetType().Name
                );
                throw new NetClientException(
                    (ushort)InternalErrorCode.RequestTimeout,
                    $"Request timed out after {_config.RequestTimeout.TotalMilliseconds}ms - MsgId: {msgId}",
                    ex,
                    request
                );
            }
            catch (InvalidOperationException ex) when (ex.Message.Contains("RequestId collision"))
            {
                _logger.LogError(ex, "RequestId collision occurred");
                throw;
            }
        }

        public void Update()
        {
            if (State == ClientState.Disconnected)
                return;

            ProcessPacket();
        }

        private void ProcessPacket()
        {
            while (_recvList.TryDequeue(out var packet))
            {
                _handler.Handling(packet);
            }
        }

        private void EnqueueSend(Header header, IMessage message)
        {
            var size = (header, message).CalcSize();
            var buffer = ArrayPool<byte>.Shared.Rent(size);
            try
            {
                (header, message).WriteToSpan(buffer);
                base.SendAsync(buffer, 0, size);
            }
            catch (Exception e)
            {
                _logger.LogError(e, "Error writing message to client");
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }

        protected override void OnConnected()
        {
            _logger.LogInformation("Client connected - [sid:{Sid}]", Sid);

            _connectTcs?.SetResult(true);
            OnConnect?.Invoke(true);
        }

        protected override void OnDisconnected()
        {
            _logger.LogInformation("TCP client disconnected - [sid:{Sid}]", Sid);

            _connectTcs?.SetCanceled();
            _rpcManager.CancelAll();

            OnDisconnect?.Invoke();
        }

        protected override void OnError(SocketError error)
        {
            _logger.LogWarning("Socket error: {Error} [sid:{Sid}]", error, Sid);
        }

        protected override void OnReceived(byte[] buffer, long offset, long size)
        {
            try
            {
                _receiveBuffer.Write(buffer.AsSpan((int)offset, (int)size));
                var packets = _packetParser.Parse(_receiveBuffer);
                if (packets.Count == 0)
                    return;

                foreach (var packet in packets)
                {
                    // RPC 응답 처리
                    if (packet.Header.RequestId > 0)
                    {
                        if (_rpcManager.TryCompleteRequest(packet.Header.RequestId, packet.Message))
                        {
                            continue;
                        }

                        // 타임아웃된 응답 로깅
                        _logger.LogWarning(
                            "Received response for unknown/expired RequestId: {RequestId}, MsgId: {MsgId}",
                            packet.Header.RequestId,
                            packet.Header.MsgId
                        );
                    }

                    // 메시지 큐 크기 제한 (DoS 방어)
                    if (_recvList.Count >= _config.MaxQueueSize)
                    {
                        _logger.LogError(
                            "Message queue full ({MaxSize}), dropping packet - MsgId: {MsgId}",
                            _config.MaxQueueSize,
                            packet.Header.MsgId
                        );
                        Disconnect();
                        return;
                    }

                    _recvList.Enqueue(packet);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "OnReceived Exception");
                Disconnect();
            }
        }

        public new void Dispose()
        {
            // 자식 리소스 먼저 정리
            _connectTcs?.TrySetCanceled();
            _rpcManager?.Dispose();
            _receiveBuffer?.Dispose();

            // 부모 리소스 마지막에 정리
            base.Dispose();
        }
    }
}
