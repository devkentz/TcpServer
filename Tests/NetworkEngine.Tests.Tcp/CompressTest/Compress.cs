using NetworkServer.ProtoAutoGen;
using NetworkServer.ProtoGenerator;
using Proto.Test;
using Xunit;
using Xunit.Abstractions;

namespace NetworkEngine.Tests.Node.CompressTest;

// 1. 테스트용 Protobuf 메시지 (수동 구현)

public class CompressTests(ITestOutputHelper output) : IAsyncLifetime
{

    public Task InitializeAsync()
    {
        return Task.CompletedTask;
    }

    public Task DisposeAsync()
    {
        return Task.CompletedTask;
    }


    [Fact(DisplayName = "정상 흐름: 직렬화 및 압축 후, 해제 시 원본과 동일해야 한다")]
    public void Compress_And_Decompress_ShouldReturnOriginalMessage()
    {
        // Arrange
        var originalMessage = new CompressMessage {Content = "Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.\n\n", Value = 12345};

        foreach (var _ in Enumerable.Range(0, 10))
        {
            originalMessage.Content += originalMessage.Content;
        }
        
        byte[] outputBuffer = new byte[originalMessage.CalculateSize() * 10];

        // Act - 1. Compress
        int compressedSize = ProtobufCompressor.Compress(originalMessage, outputBuffer);

        // Act - 2. Decompress
        // (실제 시나리오에서는 네트워크 헤더 등에서 originalSize를 알 수 있다고 가정)
        int originalSize = originalMessage.CalculateSize();
        ReadOnlySpan<byte> compressedData = outputBuffer.AsSpan(0, compressedSize);

        var parser = AutoGeneratedParsers.GetParserById(Proto.Test.CompressMessage.MsgId);
        if (parser == null)
            throw new Exception($"Invalid message ID : {Proto.Test.CompressMessage.MsgId}");

        var decompressedMessage = (CompressMessage) ProtobufCompressor.DecompressMessage(parser, compressedData, originalSize);

        // Assert
        Assert.NotNull(decompressedMessage);
        Assert.Equal(originalMessage.Content, decompressedMessage.Content);
        Assert.Equal(originalMessage.Value, decompressedMessage.Value);

        output.WriteLine($"{originalSize}");
        output.WriteLine($"{compressedSize}");
    }

    [Fact(DisplayName = "Compress: 출력 버퍼가 너무 작으면 ArgumentException이 발생해야 한다")]
    public void Compress_SmallBuffer_ShouldThrowArgumentException()
    {
        // Arrange
        var message = new Proto.Test.CompressMessage {Content = new string('A', 1000)}; // 꽤 큰 데이터
        var smallBuffer = new byte[10]; // 터무니없이 작은 버퍼

        // Act & Assert
        var ex = Assert.Throws<ArgumentException>(() => ProtobufCompressor.Compress(message, smallBuffer));

        Assert.Contains("Output buffer too small", ex.Message);
    }

    [Fact(DisplayName = "Decompress: 원본 크기가 MaxBufferSize를 초과하면 InvalidOperationException 발생")]
    public void Decompress_TooLargeSize_ShouldThrowInvalidOperationException()
    {
        // Arrange
        var dummyCompressed = new byte[] {0x01}; // 데이터는 상관없음
        int fakeOriginalSize = (1024 * 1024 * 2) + 1; // 2MB + 1byte

        // Act & Assert
        var ex = Assert.Throws<InvalidOperationException>(() =>
            ProtobufCompressor.DecompressMessage(CompressMessage.Descriptor.Parser, dummyCompressed, fakeOriginalSize));

        Assert.Contains("exceeds MaxBufferSize", ex.Message);
    }

    [Fact(DisplayName = "Decompress: 압축 해제된 크기가 예상 크기와 다르면(데이터 오염) 예외 발생")]
    public void Decompress_SizeMismatch_ShouldThrowInvalidOperationException()
    {
        // Arrange
        var originalMessage = new Proto.Test.CompressMessage {Content = "Test"};
        int originalSize = originalMessage.CalculateSize();

        // 정상 압축
        byte[] buffer = new byte[100];
        int compressedSize = ProtobufCompressor.Compress(originalMessage, buffer);

        // 데이터 조작 (압축 데이터를 임의로 잘라냄 -> LZ4 디코딩 시 크기가 안 맞거나 에러 발생)
        // 여기서는 LZ4가 에러를 뱉지 않더라도 결과 길이가 다를 상황을 유도하기 위해
        // '예상 크기'를 억지로 다르게 주입합니다.
        int wrongExpectedSize = originalSize + 50;

        // Act & Assert
        var ex = Assert.Throws<InvalidOperationException>(() =>
                ProtobufCompressor.DecompressMessage(CompressMessage.Descriptor.Parser, buffer.AsSpan(0, compressedSize), wrongExpectedSize) // 틀린 사이즈 주입
        );

        Assert.Contains("Decompressed size", ex.Message);
    }


    [Fact(DisplayName = "멀티쓰레드: 10,000번 동시 압축/해제 시 데이터 오염이 없어야 한다")]
    public void Parallel_Compress_Decompress_ShouldBeThreadSafe()
    {
        // Arrange
        int totalIterations = 10000; // 반복 횟수 (부하 강도 조절)
        int maxDegreeOfParallelism = Environment.ProcessorCount * 2; // CPU 코어 수의 2배만큼 동시 실행

        var parallelOptions = new ParallelOptions {MaxDegreeOfParallelism = maxDegreeOfParallelism};

        // Act & Assert
        // Parallel.For는 내부적으로 예외 발생 시 AggregateException을 던져 테스트를 실패하게 만듭니다.
        Parallel.For(0, totalIterations, parallelOptions, (i) =>
        {
            // 1. 각 쓰레드/반복마다 고유한 데이터 생성
            var threadId = Thread.CurrentThread.ManagedThreadId;
            var originalMsg = new ThreadTestMessage
            {
                ThreadId = threadId,
                Iteration = i,
                Payload = $"Payload-Data-{i}-{Guid.NewGuid()}" + string.Join(",", Enumerable.Range(0, 100).Select( e => "hello"))  // 고유한 문자열
            };

            // 2. 압축 (각 쓰레드는 자신만의 outputBuffer를 가져야 함)
            // 주의: outputBuffer를 쓰레드끼리 공유하면 당연히 데이터가 섞입니다. (Caller의 책임)
            byte[] outputBuffer = new byte[originalMsg.CalculateSize() + 1024];
            int compressedSize = ProtobufCompressor.Compress(originalMsg, outputBuffer);

            // 3. 해제
            int originalSize = originalMsg.CalculateSize();
            var decompressedMsg = (ThreadTestMessage) ProtobufCompressor.DecompressMessage(ThreadTestMessage.Parser, outputBuffer.AsSpan(0, compressedSize),
                originalSize
            );

            // 4. 검증 (데이터 정합성 확인)
            // 만약 Race Condition이 발생했다면 ID나 Payload가 섞여서 이 부분이 실패함
            if (decompressedMsg.Iteration != i)
            {
                throw new Exception($"Data Corruption! Expected Iteration {i}, Got {decompressedMsg.Iteration}");
            }

            if (decompressedMsg.Payload != originalMsg.Payload)
            {
                throw new Exception($"Payload Mismatch! Thread {threadId} corrupted.");
            }

            output.WriteLine($"compresSize : {compressedSize}, originalSize : {originalSize}");
        });
    }
}