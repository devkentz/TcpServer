using System.Buffers;
using System.Diagnostics;
using System.Runtime.InteropServices;
using Google.Protobuf;
using NetMQ;
using NetworkServer.ProtoGenerator;

namespace Network.Server.Common.Packets;

[StructLayout(LayoutKind.Sequential, Pack = 1)]
public struct InternalHeader
{
    public long Dest;
    public long Source;
    public long ActorId;
    public int MsgId;
    public byte IsReply;
    public int RequestKey;

    public const int Size =
        sizeof(long) * 3 + sizeof(int) + sizeof(byte) + sizeof(int);
    // Dest + Source + ActorId + MsgId + RequestKey
}

public class InternalPacket : IDisposable
{
    public const long ServerActorId = 0;

    private InternalHeader _header;

    public InternalHeader Header => _header;

    public Msg Msg;
    public long Dest => _header.Dest;
    public long Source => _header.Source;
    public long ActorId => _header.ActorId;
    public int RequestKey => _header.RequestKey;
    public bool IsReply => _header.IsReply == 1;
    public int MsgId => _header.MsgId;

    public int Size => InternalHeader.Size;

    public Span<byte> Payload =>
        Msg.Slice(_offset, _length); //[[MsgIdLength + MsgId] + IMessage] or [Header + IMessage]

    public int Length => Size + _length;

    private int _offset;
    private int _length;
    
    private byte[]? _rentBuffer;

    private InternalPacket()
    {
        _length = 0;
    }

    public static InternalPacket Create(ref Msg msg)
    {
        var span = msg.Slice();

        Debug.Assert(span.Length >= InternalHeader.Size);

        var packet = new InternalPacket();
        packet._header = MemoryMarshal.Read<InternalHeader>(span);
        packet._offset = InternalHeader.Size;
        packet._length = span.Length - InternalHeader.Size;
        packet.Msg.Move(ref msg);
        return packet;
    }

    public static InternalPacket Create(long actorId, long srcId, long destId, int requestKey, bool isReply,
        IMessage message)
    {
        var msgId = AutoGeneratedParsers.GetIdByInstance(message);
        var length = message.CalculateSize() + InternalHeader.Size;

        var packet = new InternalPacket();
        packet.SetBuffer(length);

        var span = packet.HeaderSpan();
        packet._header = new InternalHeader
        {
            Dest = destId,
            Source = srcId,
            ActorId = actorId,
            MsgId = msgId,
            IsReply = isReply ? (byte) 1 : (byte) 0,
            RequestKey = requestKey
        };

        packet._offset = InternalHeader.Size;
        packet._length = length - InternalHeader.Size;
        MemoryMarshal.Write(span, in packet._header);
        message.WriteTo(packet.Msg.Slice(InternalHeader.Size, (length - InternalHeader.Size)));
        return packet;
    }

    private byte[] SetBuffer(int length)
    {
        //_rentBuffer = BufferPool.Rent(length);
        Msg.InitPool(length);
        return _rentBuffer;
    }

    public static InternalPacket CreateResponse(long actorId, InternalHeader request, IMessage message)
        => Create(actorId, request.Dest, request.Source, request.RequestKey, true, message);

    private Span<byte> HeaderSpan()
    {
        return Msg.Slice(0, Size);
    }

    public void MoveMsg(ref Msg target)
    {
        target.Move(ref Msg);
    }

    //
    public void Dispose()
    {
        if (Msg.IsInitialised) 
            Msg.Close();
    }
}